yi.star <- qnorm(halt2[,3], mean = yi, sd = delta)
yj.star <- qnorm(halt2[,4], mean = yj, sd = delta)
u.star <- sqrt((xi.star - xj.star)^2 + (yi.star - yj.star)^2)
mean(dnorm(yij, mean = 0,
sd = sqrt(2*(nugget + sigma2*(1 - matern(u.star, phi = phi, kappa = kappa))))))
sim_spdata <- function(locations, cov_model = "matern", cov_pars = c(1, 0.16), nugget = 0.5, kappa = 0.5) {
npts <- nrow(locations)
sigma2 <- cov_pars[1]
phi <- cov_pars[2]
kappa <- cov_pars[3]
#Prepare cholesky matrix to simulate data
d_true <- as.matrix(dist(locs.true))
sigma <- diag(nugget, nrow = npts) + cov.spatial(d.true, cov_pars = cov_pars, cov.model = cov_model, kappa = kappa)
L <- t(chol(sigma))
Z <- matrix(rnorm(npts), nrow = npts, ncol = 1)
data <- L %*% Z
}
npts <- 100
locs.true <- matrix(runif(npts*2, min = 0, max = 15), ncol = 2)
sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
sim_spdata <- function(locations, cov_model = "matern", cov_pars = c(1, 0.16), nugget = 0.5, kappa = 0.5) {
npts <- nrow(locations)
kappa <- kappa
nugget <- nugget
#Prepare cholesky matrix to simulate data
d_true <- as.matrix(dist(locs.true))
sigma <- diag(nugget, nrow = npts) +
cov.spatial(d.true, cov.pars = cov_pars, cov.model = cov_model, kappa = kappa)
L <- t(chol(sigma))
Z <- matrix(rnorm(npts), nrow = npts, ncol = 1)
data <- L %*% Z
}
sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
sim_spdata <- function(locations, cov_model = "matern", cov_pars = c(1, 0.16), nugget = 0.5, kappa = 0.5) {
npts <- nrow(locations)
kappa <- kappa
nugget <- nugget
#Prepare cholesky matrix to simulate data
d_true <- as.matrix(dist(locs.true))
sigma <- diag(nugget, nrow = npts) +
cov.spatial(d_true, cov.pars = cov_pars, cov.model = cov_model, kappa = kappa)
L <- t(chol(sigma))
Z <- matrix(rnorm(npts), nrow = npts, ncol = 1)
data <- L %*% Z
}
sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
npts <- nrow(locations)
sim_spdata <- function(locations, cov_model = "matern", cov_pars = c(1, 0.16), nugget = 0.5, kappa = 0.5) {
npts <- nrow(locations)
kappa <- kappa
nugget <- nugget
#Prepare cholesky matrix to simulate data
d_true <- as.matrix(dist(locs.true))
sigma <- diag(nugget, nrow = npts) +
cov.spatial(d_true, cov.pars = cov_pars, cov.model = cov_model, kappa = kappa)
L <- t(chol(sigma))
Z <- matrix(rnorm(npts), nrow = npts, ncol = 1)
data <- L %*% Z
return(data)
}
sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
prova <- sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
class(prova)
dim(prova)
#' @param locations
#' @param cov_model
#' @param cov_pars
#' @param nugget
#' @param kappa
#'
#' @return
#' @export
#'
#' @examples
sim_spdata <- function(locations, cov_model = "matern", cov_pars = c(1, 0.16), nugget = 0.5, kappa = 0.5) {
npts <- nrow(locations)
kappa <- kappa
nugget <- nugget
#Prepare cholesky matrix to simulate data
d_true <- as.matrix(dist(locs.true))
sigma <- diag(nugget, nrow = npts) +
cov.spatial(d_true, cov.pars = cov_pars, cov.model = cov_model, kappa = kappa)
L <- t(chol(sigma))
Z <- matrix(rnorm(npts), nrow = npts, ncol = 1)
data <- L %*% Z
return(as.numeric(data))
}
prova <- sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
dim(prova)
class(prova)
install.packages("gstat")
library(geomask)
rm(sim_spdata())
rm(sim_spdata
)
library(geomask)
install.packages("roxygen2")
library(geomask)
npts <- 100
locs.true <- matrix(runif(npts*2, min = 0, max = 15), ncol = 2)
df <- sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
library(geomask)
locs_obs <- geomasking(locs.true, displacement = "gaussian", delta = 0.5)
varioadj(df, locs_obs, delta = 0.5, kappa = 0.5, ini = c(1, 0.16, 0.5))
library(sp)
devtools::use_package("sp")
varioadj(df, locs_obs, delta = 0.5, kappa = 0.5, ini = c(1, 0.16, 0.5))
library(geomask)
library(geomask)
varioadj(df, locs_obs, delta = 0.5, kappa = 0.5, ini = c(1, 0.16, 0.5))
library("gstat", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.4")
varioadj(df, locs_obs, delta = 0.5, kappa = 0.5, ini = c(1, 0.16, 0.5))
npts <- 100
locs.true <- matrix(runif(npts*2, min = 0, max = 15), ncol = 2)
df <- sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
locs_obs <- geomasking(locs.true, displacement = "gaussian", delta = 0.5)
varioadj(df, locs_obs, delta = 0.5, kappa = 0.5, ini = c(1, 0.16, 0.5))
npts <- 100
locs.true <- matrix(runif(npts*2, min = 0, max = 15), ncol = 2)
df <- sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
locs_obs <- geomasking(locs.true, displacement = "gaussian", delta = 0.5)
varioadj(df, locs_obs, delta = 0.5, kappa = 0.5, ini = c(1, 0.16, 0.5))
npts <- 100
locs.true <- matrix(runif(npts*2, min = 0, max = 15), ncol = 2)
df <- sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
locs_obs <- geomasking(locs.true, displacement = "gaussian", delta = 0.5)
varioadj(df, locs_obs, delta = 0.5, kappa = 0.5, ini = c(1, 0.16, 0.5))
npts <- 100
locs.true <- matrix(runif(npts*2, min = 0, max = 15), ncol = 2)
df <- sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
locs_obs <- geomasking(locs.true, displacement = "gaussian", delta = 0.5)
varioadj(df, locs_obs, delta = 0.5, kappa = 0.5, ini = c(1, 0.16, 0.5))
npts <- 100
locs.true <- matrix(runif(npts*2, min = 0, max = 15), ncol = 2)
df <- sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
locs_obs <- geomasking(locs.true, displacement = "gaussian", delta = 0.5)
varioadj(df, locs_obs, delta = 0.5, kappa = 0.5, ini = c(1, 0.16, 0.5))
npts <- 100
locs.true <- matrix(runif(npts*2, min = 0, max = 15), ncol = 2)
df <- sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
locs_obs <- geomasking(locs.true, displacement = "gaussian", delta = 0.5)
varioadj(df, locs_obs, delta = 0.5, kappa = 0.5, ini = c(1, 0.16, 0.5))
npts <- 100
locs.true <- matrix(runif(npts*2, min = 0, max = 15), ncol = 2)
df <- sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
locs_obs <- geomasking(locs.true, displacement = "gaussian", delta = 0.5)
varioadj(df, locs_obs, delta = 0.5, kappa = 0.5, ini = c(1, 0.16, 0.5))
npts <- 1000
locs.true <- matrix(runif(npts*2, min = 0, max = 15), ncol = 2)
df <- sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
locs_obs <- geomasking(locs.true, displacement = "gaussian", delta = 0.5)
varioadj(df, locs_obs, delta = 0.5, kappa = 0.5, ini = c(1, 0.16, 0.5))
npts <- 1000
locs.true <- matrix(runif(npts*2, min = 0, max = 15), ncol = 2)
df <- sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
locs_obs <- geomasking(locs.true, displacement = "gaussian", delta = 0.5)
varioadj(df, locs_obs, delta = 0.5, kappa = 0.5, ini = c(1, 0.16, 0.5))
npts <- 1000
locs.true <- matrix(runif(npts*2, min = 0, max = 15), ncol = 2)
df <- sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
locs_obs <- geomasking(locs.true, displacement = "gaussian", delta = 0.5)
varioadj(df, locs_obs, delta = 0.5, kappa = 0.5, ini = c(1, 0.16, 0.5))
npts <- 1000
locs.true <- matrix(runif(npts*2, min = 0, max = 15), ncol = 2)
df <- sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
locs_obs <- geomasking(locs.true, displacement = "gaussian", delta = 0.5)
varioadj(df, locs_obs, delta = 0.5, kappa = 0.5, ini = c(1, 0.16, 0.5))
npts <- 1000
locs.true <- matrix(runif(npts*2, min = 0, max = 15), ncol = 2)
df <- sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
locs_obs <- geomasking(locs.true, displacement = "gaussian", delta = 0.5)
varioadj(df, locs_obs, delta = 0.5, kappa = 0.5, ini = c(1, 0.16, 0.5))
npts <- 1000
locs.true <- matrix(runif(npts*2, min = 0, max = 15), ncol = 2)
df <- sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
locs_obs <- geomasking(locs.true, displacement = "gaussian", delta = 0.5)
varioadj(df, locs_obs, delta = 0.5, kappa = 0.5, ini = c(1, 0.16, 0.5))
npts <- 1000
locs.true <- matrix(runif(npts*2, min = 0, max = 15), ncol = 2)
df <- sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
locs_obs <- geomasking(locs.true, displacement = "gaussian", delta = 0.5)
varioadj(df, locs_obs, delta = 0.5, kappa = 0.5, ini = c(1, 0.16, 0.5))
npts <- 1000
locs.true <- matrix(runif(npts*2, min = 0, max = 15), ncol = 2)
df <- sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
locs_obs <- geomasking(locs.true, displacement = "gaussian", delta = 0.5)
varioadj(df, locs_obs, delta = 0.5, kappa = 0.5, ini = c(1, 0.16, 0.5))
library(geomask)
library(geomask)
library(geomask)
npts <- 100
locs.true <- matrix(runif(npts*2, min = 0, max = 15), ncol = 2)
df <- sim_spdata(locations = locs.true, cov_model = "matern", cov_pars = c(1, 0.16), kappa = 0.5, nugget = 0.5)
locs_obs <- geomasking(locs.true, displacement = "gaussian", delta = 0.5)
varioadj(df, locs_obs, delta = 0.5, kappa = 0.5, ini = c(1, 0.16, 0.5))
fit_geoadj(df, locs_obs, delta = 0.5, kappa = 0.5, approx = T, ini = c(1, 0.16, 0.5))
library(geomask)
fit_geoadj(df, locs_obs, delta = 0.5, kappa = 0.5, approx = T, ini = c(1, 0.16, 0.5))
library(geomask)
fit_geoadj(df, locs_obs, delta = 0.5, kappa = 0.5, approx = T, ini = c(1, 0.16, 0.5))
library(geomask)
fit_geoadj(df, locs_obs, delta = 0.5, kappa = 0.5, approx = T, ini = c(1, 0.16, 0.5))
library(geomask)
fit_geoadj(df, locs_obs, delta = 0.5, kappa = 0.5, approx = T, ini = c(1, 0.16, 0.5))
fit_geoadj(df, locs_obs, delta = 0.5, kappa = 0.5, approx = F, ini = c(1, 0.16, 0.5))
library(geomask)
fit_geoadj(df, locs_obs, delta = 0.5, kappa = 0.5, approx = F, ini = c(1, 0.16, 0.5))
fit_geoadj(df, locs_obs, delta = 0.5, kappa = 0.5, approx = T, ini = c(1, 0.16, 0.5))
data <- df
data
locations <- locs_obs
npts <- nrow(locations)
locs.obs <- locations
r <- thresh
# Prepare data
id <- t(combn(npts, 2))
res <- t(apply(id, MARGIN = 1, FUN = function(x) {
cbind(yi =data[x[1]] , yj = data[x[2]],  x1 = locs.obs[x[1], 1],
y1 = locs.obs[x[1], 2],  x2 = locs.obs[x[2], 1],  y2 = locs.obs[x[2], 2])
}))
res
head(res)
head
dij <- sapply(1:nrow(id), FUN = function(x) dist(rbind(locs.obs[id[x,1],], locs.obs[id[x,2], ])))
dij
res <- cbind(res, dij)
colnames(res) <- c("yi", "yj", "x1", "y1", "x2", "y2", "dij")
library(geomask)
fit_geoadj(df, locs_obs, delta = 0.5, kappa = 0.5, approx = F, ini = c(1, 0.16, 0.5))
fit_geoadj(df, locs_obs, delta = 0.5, kappa = 0.5, approx = T, ini = c(1, 0.16, 0.5))
library(geoR)
library(raster)
library(flexclust)
devtools::use_package("raster")
devtools::use_package("flexclust")
install.packages("flexclust")
devtools::use_package("flexclust")
# Generate the original locations
r <- 10 ##grid resolution
coords <- as.matrix(expand.grid(seq(0, 1, length.out = r), seq(0, 1, length.out = r)))
plot(coords)
n <- nrow(coords) #number of locations
# Nugget
nugget <- 0
sigma2 <- 1
phi <- 0.1
cov.model <- "matern"
kappa <- 0.5
practicalRange("matern", phi, kappa)
d <- as.matrix(dist(coords))
sigma <- diag(nugget, nrow = n) + cov.spatial(d, cov.pars = c(sigma2, phi), cov.model = cov.model, kappa = kappa)
L <- t(chol(sigma))
Z <- matrix(rnorm(n), nrow = n, ncol = 1)
S <- L %*% Z
# Simulate two covariates
d1 <- rnorm(n)
d2 <- rnorm(n)
D <- cbind(d1, d2)
beta <- as.matrix(c(3.5, - 1.2))
#Generate the data from the model
Y <- rnorm(n, mean = S, sd = 0)
# Convert to raster
xyz = data.frame(x = coords[,1], y = coords[,2], z = Y)
rs <- rasterFromXYZ(xyz)
plot(rs)
# Aggregate everything to a coarse resolution
rs.coarse <- aggregate(rs, 2)
ncell(rs.coarse)
plot(rs.coarse)
# Convert back to points
df <- rasterToPoints(rs.coarse)
#Run the model
#trend.d <- trend.spatial(~ df[, 4] + df[, 5])
fit <- likfit(coords = df[, 1:2],
data = df[, 3],
fix.nugget = T,
nugget = 0,
ini.cov.pars = c(sigma2, phi),
cov.model = "matern",
kappa = 0.5)
fit
###########################
##### AGGREGATED DATA #####
###########################
mc_corr <- function(i, j, phi) {
p1 <- pp[pp[,"block"] == i, c(1,2)]
p2 <- pp[pp[,"block"] == j, c(1,2)]
blockdist <- dist2(p1, p2)[upper.tri((dist2(p1, p2)), diag = T)]
sum(matern(blockdist, phi = phi, kappa = kappa))/(nrow(p1)*nrow(p2))
}
nblocks <- ncell(rs.coarse)
id <- which(upper.tri(matrix(0, nrow = nblocks, ncol = nblocks), diag = T), arr.ind = T)
n0 <- 0
res1 <- 1
res2 <- 2
while(mean((res1 - res2)^2) > 10^(-4)) {
n1 <- n0 + 10
n2 <- n1 + 10
xy <- spsample(as(extent(rs.coarse$z), "SpatialPolygons"), n = n1*nblocks, type = "regular")
pp <- data.frame(x = coordinates(xy)[,1], y = coordinates(xy)[ , 2], block = cellFromXY(rs.coarse$z, xy))
res1 <- apply(id, 1, function(x) mc_corr(i = x[1], j = x[2], phi = 0.2))
xy <- spsample(as(extent(rs.coarse$z), "SpatialPolygons"), n = n2*nblocks, type = "regular")
pp <- data.frame(x = coordinates(xy)[,1], y = coordinates(xy)[ , 2], block = cellFromXY(rs.coarse$z, xy))
res2 <- apply(id, 1, function(x) mc_corr(i = x[1], j = x[2], phi = 0.2))
n0 <- n0 + 10
print(c(n1,n2))
}
mc.points <- n2
xy <- spsample(as(extent(rs.coarse$z), "SpatialPolygons"), n = mc.points*nblocks, type = "regular")
plot(rs.coarse$z, asp = 1)
points(xy, pch = 19, cex = 0.1)
table(cellFromXY(rs.coarse$z, xy))
pp <- data.frame(x = coordinates(xy)[,1], y = coordinates(xy)[ , 2], block = cellFromXY(rs.coarse$z, xy))
system.time(apply(id, 1, function(x) mc_corr(i = x[1], j = x[2], phi = phi)))
###########################
##### AGGREGATED DATA #####
###########################
mc_corr <- function(i, j, phi) {
p1 <- pp[pp[,"block"] == i, c(1,2)]
p2 <- pp[pp[,"block"] == j, c(1,2)]
blockdist <- dist2(p1, p2)[upper.tri((flexclust::dist2(p1, p2)), diag = T)]
sum(matern(blockdist, phi = phi, kappa = kappa))/(nrow(p1)*nrow(p2))
}
nblocks <- ncell(rs.coarse)
id <- which(upper.tri(matrix(0, nrow = nblocks, ncol = nblocks), diag = T), arr.ind = T)
n0 <- 0
res1 <- 1
res2 <- 2
while(mean((res1 - res2)^2) > 10^(-4)) {
n1 <- n0 + 10
n2 <- n1 + 10
xy <- spsample(as(extent(rs.coarse$z), "SpatialPolygons"), n = n1*nblocks, type = "regular")
pp <- data.frame(x = coordinates(xy)[,1], y = coordinates(xy)[ , 2], block = cellFromXY(rs.coarse$z, xy))
res1 <- apply(id, 1, function(x) mc_corr(i = x[1], j = x[2], phi = 0.2))
xy <- spsample(as(extent(rs.coarse$z), "SpatialPolygons"), n = n2*nblocks, type = "regular")
pp <- data.frame(x = coordinates(xy)[,1], y = coordinates(xy)[ , 2], block = cellFromXY(rs.coarse$z, xy))
res2 <- apply(id, 1, function(x) mc_corr(i = x[1], j = x[2], phi = 0.2))
n0 <- n0 + 10
print(c(n1,n2))
}
mc.points <- n2
xy <- spsample(as(extent(rs.coarse$z), "SpatialPolygons"), n = mc.points*nblocks, type = "regular")
plot(rs.coarse$z, asp = 1)
points(xy, pch = 19, cex = 0.1)
table(cellFromXY(rs.coarse$z, xy))
pp <- data.frame(x = coordinates(xy)[,1], y = coordinates(xy)[ , 2], block = cellFromXY(rs.coarse$z, xy))
system.time(apply(id, 1, function(x) mc_corr(i = x[1], j = x[2], phi = phi)))
install.packages("flexclust")
###########################
##### AGGREGATED DATA #####
###########################
mc_corr <- function(i, j, phi) {
p1 <- pp[pp[,"block"] == i, c(1,2)]
p2 <- pp[pp[,"block"] == j, c(1,2)]
blockdist <- flexclust::dist2(p1, p2)[upper.tri((flexclust::dist2(p1, p2)), diag = T)]
sum(matern(blockdist, phi = phi, kappa = kappa))/(nrow(p1)*nrow(p2))
}
nblocks <- ncell(rs.coarse)
id <- which(upper.tri(matrix(0, nrow = nblocks, ncol = nblocks), diag = T), arr.ind = T)
n0 <- 0
res1 <- 1
res2 <- 2
while(mean((res1 - res2)^2) > 10^(-4)) {
n1 <- n0 + 10
n2 <- n1 + 10
xy <- spsample(as(extent(rs.coarse$z), "SpatialPolygons"), n = n1*nblocks, type = "regular")
pp <- data.frame(x = coordinates(xy)[,1], y = coordinates(xy)[ , 2], block = cellFromXY(rs.coarse$z, xy))
res1 <- apply(id, 1, function(x) mc_corr(i = x[1], j = x[2], phi = 0.2))
xy <- spsample(as(extent(rs.coarse$z), "SpatialPolygons"), n = n2*nblocks, type = "regular")
pp <- data.frame(x = coordinates(xy)[,1], y = coordinates(xy)[ , 2], block = cellFromXY(rs.coarse$z, xy))
res2 <- apply(id, 1, function(x) mc_corr(i = x[1], j = x[2], phi = 0.2))
n0 <- n0 + 10
print(c(n1,n2))
}
mc.points <- n2
xy <- spsample(as(extent(rs.coarse$z), "SpatialPolygons"), n = mc.points*nblocks, type = "regular")
plot(rs.coarse$z, asp = 1)
points(xy, pch = 19, cex = 0.1)
table(cellFromXY(rs.coarse$z, xy))
pp <- data.frame(x = coordinates(xy)[,1], y = coordinates(xy)[ , 2], block = cellFromXY(rs.coarse$z, xy))
system.time(apply(id, 1, function(x) mc_corr(i = x[1], j = x[2], phi = phi)))
Dm <- df[,c("d1", "d2")]
Y <- as.matrix(df[,c("z")])
f.loss <- function(pars, y) {
sigma2 <- exp(pars[1])
phi <- exp(pars[2])
nblocks <- length(y)
corr <- matrix(0, nrow = nblocks, ncol = nblocks)
res <- apply(id, 1, function(x) mc_corr(i = x[1], j = x[2], phi = phi))
corr[upper.tri(corr, diag = T)] <- res
corr[lower.tri(corr)] <- t(corr)[lower.tri(corr)]
diag(corr) <- diag(corr) + sigma2
ldet.5 <- as.numeric(determinant(corr, logarithm = T)$modulus/2)
corr <- solve(corr)
beta_hat <- solve(crossprod(ff, corr)%*%ff,
crossprod(ff, corr)%*%y)
z <- y - ff%*%beta_hat
sigma2_hat <- mean(crossprod(corr,z)*z)
log_lik <- ldet.5 + nblocks*(1 + log(2*pi*sigma2_hat))/2
attr(log_lik, "param") <- c(beta = beta_hat, sigma2 = sigma2_hat, phi = phi, nugget = nu*sigma2_hat)
return(log_lik)
}
f.loss(pars = log(c(nugget/sigma2, phi)), ff = cbind(1,Dm), y = Y)
fit
system.time(cla <- optim(par = log(c(nugget/sigma2, phi)), fn = f.loss, ff = cbind(1, Dm), y = Y))
exp(cla$par)
f.loss(pars = cla$par, ff = cbind(1,Dm), y = Y)
round(attr(f.loss(pars = cla$par, ff = cbind(1,Dm), y = Y), "param"), digits = 4)
f.loss3 <- function(pars, ff, y) {
sigmasq <- exp(pars[1])
phi <- exp(pars[2])
tausq <- exp(pars[3])
nblocks <- length(y)
corr <- matrix(0, nrow = nblocks, ncol = nblocks)
res <- apply(id, 1, function(x) mc_corr(i = x[1], j = x[2], phi = phi))
corr[upper.tri(corr, diag = T)] <- res
corr[lower.tri(corr)] <- t(corr)[lower.tri(corr)]
diag(corr) <- diag(corr) + tausq
corr <- chol(corr)
ldet.5 <- sum(log(diag(corr)))
corr <- chol2inv(corr)
# beta_hat <- solve(crossprod(ff, corr)%*%ff,
#                   crossprod(ff, corr)%*%y)
log_lik <- ldet.5 + nblocks*(1 + log(2*pi*sigmasq))/2
#attr(log_lik, "param") <- c(beta = beta_hat, sigma2 = sigmasq, phi = phi, nugget = tausq)
return(log_lik)
}
f.loss3(pars = log(c(10, 0.15, 5)), ff = cbind(1,Dm), y = Y)
fit
system.time(cla <- optim(par = log(c(10, 0.15, 5)), fn = f.loss3, ff = cbind(1, Dm), y = Y))
exp(cla$par)
f.loss(pars = cla$par, ff = cbind(1,Dm), y = Y)
round(attr(f.loss(pars = cla$par, ff = cbind(1,Dm), y = Y), "param"), digits = 4)
f.loss.plot <- function(pars, ff, y) {
nu <- exp(pars[1])
phi <- exp(pars[2])
nblocks <- length(y)
comb <- t(combn(nblocks,2))
comb <- rbind(cbind(1:nblocks, 1:nblocks), comb)
res <- apply(comb, 1, function(x) mc_corr(i = x[1], j = x[2], phi = phi))
corr <- diag(res[1:nblocks] + nu)
corr[upper.tri(corr)] <- res[(nblocks + 1):length(res)]
corr[lower.tri(corr)] <- res[(nblocks + 1):length(res)]
corr <- chol(corr)
ldet.5 <- sum(log(diag(corr)))
corr <- chol2inv(corr)
beta_hat <- solve(crossprod(ff, corr)%*%ff,
crossprod(ff, corr)%*%y)
z <- y - ff%*%beta_hat
sigma2_hat <- mean(crossprod(corr,z)*z)
log_lik <- -(ldet.5 + nblocks*(1 + log(2*pi*sigma2_hat))/2)
return(log_lik)
}
l <- 10
xnu <- seq(0.4, 0.6, l = l)
xphi <- seq(0.1, 0.3, l = l)
gr <- log(expand.grid(xnu, xphi))
# s <- apply(gr, MARGIN = 1, FUN = f.loss.mc, yij = yij, locs.obs = locs.obs)
s <- apply(gr, MARGIN = 1, FUN = f.loss.plot, ff = cbind(1,Dm), y = Y)
df <- data.frame(xnu = exp(gr$Var1), xsigma = exp(gr$Var2), s)
df[which.max(s), ]
image2D(x = xnu, y = xphi, z = matrix(s, l, l), contour = TRUE)
image2D(x = xnu, y = xphi, z = matrix(s, l, l), rasterImage = TRUE,
contour = list(col = "black", labcex = 0.8, lwd = 2, alpha = 0.8))
################################################################################
library(optimx)
system.time(cla <- optimx(par = log(c(0.5, 0.5)), fn = f.loss, ff = cbind(1, Dm), y = Y,
control = list(all.methods = T, trace = 2)))
summary(cla)
exp(coef(cla))
f.loss2 <- function(pars, ff, y, m) {
nu <- exp(pars[1])
phi <- exp(pars[2])
corr <- 2^(1 - kappa)*(m/phi)^kappa*besselK(m/phi,kappa)/gamma(kappa)
diag(corr) <- 1 + nu
corr <- chol(corr)
ldet.5 <- sum(log(diag(corr)))
corr <- chol2inv(corr)
beta_hat <- solve(crossprod(ff, corr)%*%ff,
crossprod(ff, corr)%*%y)
z <- y - ff%*%beta_hat
sigma2_hat <- mean(crossprod(corr,z)*z)
log_lik <- ldet.5 + nblocks*(1 + log(2*pi*sigma2_hat))/2
attr(log_lik, "param") <- c(beta = beta_hat, sigma2 = sigma2_hat, phi = phi, nugget = nu*sigma2_hat)
return(log_lik)
}
f.loss2(pars = log(c(0, 0.2)), ff = cbind(1,Dm), y = Y, m = as.matrix(dist(df[,c(1,2)])))
system.time(cla <- optim(par = log(c(0.5, 0.5)), fn = f.loss2, ff = cbind(1, Dm), y = Y, m = as.matrix(dist(df[,c(1,2)]))))
exp(cla$par)
f.loss2(cla$par, ff = cbind(1, Dm), y = Y, m = as.matrix(dist(df[,c(1,2)])))
gres <- 50  # grid resolution
grlim <- c(0, 1)  # grid boundaries
coords <- as.matrix(expand.grid(seq(grlim[1], grlim[2], length.out = gres),
seq(grlim[1], grlim[2], length.out = gres)))
n <- nrow(coords)
# True parameters
nugget <- 0
sigma2 <- 1
phi <- 0.7
kappa <- 0.5
# Simulate the GP
d <- as.matrix(dist(coords))
sigma <- diag(nugget, nrow = n) + cov.spatial(d, cov.pars = c(sigma2, phi), cov.model = "matern", kappa = kappa)
L <- t(chol(sigma))
setwd("~/Dropbox/Lancaster/Kenya/RCode/")
source("splm_sim.R")
source("splm_sim_aggr.R")
splm_sim()
splm_sim_aggr(aggr.cell = 20, mc_points = 1000)
setwd("~/Dropbox/Rpackages/geomask")
library(geomask)
setwd("~/Dropbox/Rpackages/geomask")
